项目业务学习

记录滚动条位置，返回后能回到原点

进行批量审批

diff算法的问题

动态设置年级时间

下载文件的进度条

基本布局方案

微信小程序的分包

vue的缺点

微信小程序/uni-app生命周期问题

组件传参与生命周期的时间赛跑





分页用的就算antd里面的分页组件，其实一开始在vue的项目里面记录分页数据的时候是用vuex写的，但是后面发现这样还要考虑刷新的时候vuex会清空的问题，实现起来还是有些麻烦，然后我观察了一下b站,leetcode这些平台怎么做分页获取的。发现其实可用用路由的state或者params参数，之所以用state是因为state看不到更加安全。不过后来发现这也有不好的地方，因为是通过路由来记录的嘛，每次更新都要跳转路由，历史路由就会很多，不知道会不会有什么影响，

文件上传的话我就是用的formdata格式，另外呢，还做了一些文件大小格式的限制，这个就是根据后端要求来做的，后面通过学习，我又学到了什么什么方法，并且还有大文件上传切割的使用。

```js
  // 上传文件
    handlefileload(e) {
      let files = e.target.files;
      let param = new FormData();
      // formData重复的往一个值添加数据并不会被覆盖掉，可以全部接收到，可以通过formData.getAll('files')来查看所有插入的数据
      for (let i = 0; i < files.length; i++) {
        param.append("files", files[i]);
      }
      axios
        .post("/api/api/file/uploads", param)
        .then(() => {
          this.uploadfile();
          this.$message.success("上传成功");
        })
        .catch(() => this.$message.error("系统异常请联系管理员"));
    },
```

下载进度条

```js
     this.progress.visible = true;
        axios({
          method: "get",
          url: `/api/api/file/download?id=${fileid}&password=""`,
          responseType: "blob",
          onDownloadProgress: (progressEvent) => {
            let process =
              ((progressEvent.loaded / progressEvent.total) * 100) | 0;
            this.progress.progress = process;
            let progressText = `下载进度：${process}%`;
            this.progress.progressText = progressText;
          },
        }).then((res) => {
          //下载成功后对进度条处理
          setTimeout(() => {
            this.progress.visible = false;
            this.progress.progress = 0;
            this.progress.progressText = "等待下载中";
          }, 2000);
          this.$message.success("下载成功");
          let blob = new Blob([res.data]);
          const a = document.createElement("a");
          const url = window.URL.createObjectURL(blob);
          a.href = url;
          let tempName = res.headers["content-disposition"]
            .split(";")[1]
            .split("filename=")[1];
          tempName = decodeURI(tempName);
          a.download = tempName; // 设置下载下来的文件名
          a.click();
          window.URL.revokeObjectURL(url);
        });
```

# 项目整理

## 组件化开发

分页组件

## 轮播图

## webpack的项目

## Node项目

## 导航定位

```js
 mounted(){
    let nav = document.querySelector('.nav')
    window.addEventListener('scroll',function(){
      if(window.pageYOffset-80 > 0){
        nav.style.position = 'fixed'
        nav.style.top = '0px'
        nav.style.width = '100%'
      }else{
        nav.style.position = 'static'
        
      }
    })
  }
```

## redux Toolkit

为什么选择用这个

## 图片懒加载

为什么要懒加载图片，因为一般加载图片要比较多的流量，如果网站图片比较多要一次性加载的话，会造成页面卡顿，实际当中，我们访问一个网页，一开始只需要看到浏览器可视区域内的图片就可以了，用户不一定需要看完全部图片，当用户滚动鼠标或者滑动屏幕的时候去加载新的图片可以减少流量消费还能减轻服务器跟用户主机的压力。

使用intersectionObserver(交叉点观察者)异步观察目标对象域视口或者顶级对象交叉的状态，流程就是获取懒加载的img标签，利用利用array.prototype.slice.call(imglist)转成普通对象，然后判断浏览器是否兼容IntersectionObserver如果兼容，就创建观察者对象，查看图片是否是交叉状态，如果是就改要展示的src(data-src里面的)，然后移除observer,对图片列表依次加入到上述的观察者对象中进行观察

利用getBoundingClientRect

## 图片或者文件压缩



## 虚拟列表

简单点的就是没和数据项都设置相等的高度，然后根据浏览器的scrollTop来计算开始节点的索引，结束节点的索引就是开始节点加上视口可以容纳的项目数，视口可以容纳的项目数，跟当前可见的数据可以用computed计算出来，还有就是要设置一个大容器，把它的高度设置成所有数据后的高度，这样就能有准确对应得滚动条，还要对可见列表得dom设置偏移位置。

还可以设定多加载一些数据，这样可以防止白屏效果出现。

## 本地追加评论

是因为观察过小红书(或者某大公司的网站评论功能), 提交请求不刷新数据，一级评论追加到顶部，比滚动到最顶部位置，二级评论当前数据的最后面

## websocket实时通信