<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // promise的基本用法
    // new promise
    // 三个状态
    // resolve reject
    // then
    // catch
    // all  所有都为成功时返回按照顺序排列的结果数组，有一个失败就失败
    // any  当有一个成功就会返回成功 不管谁在前还是后
    // race  谁快返回谁
    // 链式调用
    const promise1 = new Promise((resolve, reject) => {
        resolve(2)
    })
    console.log(promise1.then(res => {
        console.log(res)
    }))
    console.log(promise1.then(res => {
        console.log(res)
    }).then(res => {console.log(res)}))
    const promiseall = Promise.all([new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(2)
        }, 2000)
    }),new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(4)
        }, 1000)
    }),new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(2)
        }, 500)
    })])
    console.log(promiseall.then(res => {
        console.log(res)
    },err => {
        console.log(err)
    }))

    const promiseany = Promise.any([new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(2)
        }, 500)
    }),new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(4)
        }, 1000)
    })])
    console.log(promiseany.then(res => {
        console.log(res)
    },err => {
        console.log(err)
    }))
    const promiserace = Promise.race([new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(2)
        }, 500)
    }),new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(4)
        }, 1000)
    })])
    console.log(promiserace.then(res => {
        console.log(res)
    },err => {
        console.log(err)
    }))

    // 手写promise类
    class Mypromise{
        static PENDING="pending";
        static FULFILLED="fulfilled";
        static REJECTED="rejected";
        constructor(func){
            this.promisestate = Mypromise.PENDING
            this.promiseresult = null
            func(this.resolve.bind(this), this.reject.bind(this))
        }
        resolve(result){
            if(this.promisestate === Mypromise.PENDING){
                this.promisestate = Mypromise.FULFILLED
                this.promiseresult = result
            }
        }
        reject(result){
            if(this.promisestate === Mypromise.PENDING){
                this.promisestate = Mypromise.REJECTED
                this.promiseresult = result
            }
        }
        then(onFulfilled, onRejected){
            const promise2 = new Mypromise((resolve, reject) => {
                if(this.promisestate = Mypromise.FULFILLED){
                    onFulfilled(this.promiseresult)
                }
                if(this.promisestate = Mypromise.REJECTED){
                    onRejected(this.promiseresult)
                }
            })
            return Mypromise
        }
    }
    let myPromise1 = new Mypromise((resolve, reject) => {
        resolve(3)
    })
    console.log(myPromise1.then(res=> {console.log(res)}),err => {})
</script>
</html>